{"version":3,"file":"urql-core.js","sources":["../src/utils/collectTypenames.ts","../src/utils/formatDocument.ts","../src/utils/maskTypename.ts","../src/utils/streamUtils.ts","../src/utils/operation.ts","../src/utils/index.ts","../src/gql.ts","../src/exchanges/cache.ts","../src/exchanges/ssr.ts","../src/exchanges/subscription.ts","../src/exchanges/debug.ts","../src/exchanges/dedup.ts","../src/exchanges/fetch.ts","../src/exchanges/compose.ts","../src/exchanges/map.ts","../src/exchanges/fallback.ts","../src/client.ts"],"sourcesContent":["interface EntityLike {\n  [key: string]: EntityLike | EntityLike[] | any;\n  __typename: string | null | void;\n}\n\nconst collectTypes = (obj: EntityLike | EntityLike[], types: Set<string>) => {\n  if (Array.isArray(obj)) {\n    for (const item of obj) collectTypes(item, types);\n  } else if (typeof obj === 'object' && obj !== null) {\n    for (const key in obj) {\n      if (key === '__typename' && typeof obj[key] === 'string') {\n        types.add(obj[key] as string);\n      } else {\n        collectTypes(obj[key], types);\n      }\n    }\n  }\n\n  return types;\n};\n\n/** Finds and returns a list of `__typename` fields found in response data.\n *\n * @privateRemarks\n * This is used by `@urql/core`’s document `cacheExchange` to find typenames\n * in a given GraphQL response’s data.\n */\nexport const collectTypenames = (response: object): string[] => [\n  ...collectTypes(response as EntityLike, new Set()),\n];\n","import type {\n  FieldNode,\n  SelectionNode,\n  DefinitionNode,\n  DirectiveNode,\n} from '@0no-co/graphql.web';\nimport { Kind } from '@0no-co/graphql.web';\nimport type { KeyedDocumentNode } from './request';\nimport { keyDocument } from './request';\nimport type { FormattedNode, TypedDocumentNode } from '../types';\n\nconst formatNode = <\n  T extends SelectionNode | DefinitionNode | TypedDocumentNode<any, any>,\n>(\n  node: T\n): FormattedNode<T> => {\n  if ('definitions' in node) {\n    const definitions: FormattedNode<DefinitionNode>[] = [];\n    for (const definition of node.definitions) {\n      const newDefinition = formatNode(definition);\n      definitions.push(newDefinition);\n    }\n\n    return { ...node, definitions } as FormattedNode<T>;\n  }\n\n  if ('directives' in node && node.directives && node.directives.length) {\n    const directives: DirectiveNode[] = [];\n    const _directives = {};\n    for (const directive of node.directives) {\n      let name = directive.name.value;\n      if (name[0] !== '_') {\n        directives.push(directive);\n      } else {\n        name = name.slice(1);\n      }\n      _directives[name] = directive;\n    }\n    node = { ...node, directives, _directives };\n  }\n\n  if ('selectionSet' in node) {\n    const selections: FormattedNode<SelectionNode>[] = [];\n    let hasTypename = node.kind === Kind.OPERATION_DEFINITION;\n    if (node.selectionSet) {\n      for (const selection of node.selectionSet.selections || []) {\n        hasTypename =\n          hasTypename ||\n          (selection.kind === Kind.FIELD &&\n            selection.name.value === '__typename' &&\n            !selection.alias);\n        const newSelection = formatNode(selection);\n        selections.push(newSelection);\n      }\n\n      if (!hasTypename) {\n        selections.push({\n          kind: Kind.FIELD,\n          name: {\n            kind: Kind.NAME,\n            value: '__typename',\n          },\n          _generated: true,\n        } as FormattedNode<FieldNode>);\n      }\n\n      return {\n        ...node,\n        selectionSet: { ...node.selectionSet, selections },\n      } as FormattedNode<T>;\n    }\n  }\n\n  return node as FormattedNode<T>;\n};\n\nconst formattedDocs = new Map<number, KeyedDocumentNode>();\n\n/** Formats a GraphQL document to add `__typename` fields and process client-side directives.\n *\n * @param node - a {@link DocumentNode}.\n * @returns a {@link FormattedDocument}\n *\n * @remarks\n * Cache {@link Exchange | Exchanges} will require typename introspection to\n * recognize types in a GraphQL response. To retrieve these typenames,\n * this function is used to add the `__typename` fields to non-root\n * selection sets of a GraphQL document.\n *\n * Additionally, this utility will process directives, filter out client-side\n * directives starting with an `_` underscore, and place a `_directives` dictionary\n * on selection nodes.\n *\n * This utility also preserves the internally computed key of the\n * document as created by {@link createRequest} to avoid any\n * formatting from being duplicated.\n *\n * @see {@link https://spec.graphql.org/October2021/#sec-Type-Name-Introspection} for more information\n * on typename introspection via the `__typename` field.\n */\nexport const formatDocument = <T extends TypedDocumentNode<any, any>>(\n  node: T\n): FormattedNode<T> => {\n  const query = keyDocument(node);\n\n  let result = formattedDocs.get(query.__key);\n  if (!result) {\n    formattedDocs.set(\n      query.__key,\n      (result = formatNode(query) as KeyedDocumentNode)\n    );\n    // Ensure that the hash of the resulting document won't suddenly change\n    // we are marking __key as non-enumerable so when external exchanges use visit\n    // to manipulate a document we won't restore the previous query due to the __key\n    // property.\n    Object.defineProperty(result, '__key', {\n      value: query.__key,\n      enumerable: false,\n    });\n  }\n\n  return result as FormattedNode<T>;\n};\n","/** Used to recursively mark `__typename` fields in data as non-enumerable.\n *\n * @deprecated Not recommended over modelling inputs manually (See #3299)\n *\n * @remarks\n * This utility can be used to recursively copy GraphQl response data and hide\n * all `__typename` fields present on it.\n *\n * Hint: It’s not recommended to do this, unless it's absolutely necessary as\n * cloning and modifying all data of a response can be unnecessarily slow, when\n * a manual and more specific copy/mask is more efficient.\n *\n * @see {@link ClientOptions.maskTypename} for a description of how the `Client` uses this utility.\n */\nexport const maskTypename = (data: any, isRoot?: boolean): any => {\n  if (!data || typeof data !== 'object') {\n    return data;\n  } else if (Array.isArray(data)) {\n    return data.map(d => maskTypename(d));\n  } else if (\n    data &&\n    typeof data === 'object' &&\n    (isRoot || '__typename' in data)\n  ) {\n    const acc = {};\n    for (const key in data) {\n      if (key === '__typename') {\n        Object.defineProperty(acc, '__typename', {\n          enumerable: false,\n          value: data.__typename,\n        });\n      } else {\n        acc[key] = maskTypename(data[key]);\n      }\n    }\n    return acc;\n  } else {\n    return data;\n  }\n};\n","import type { Sink, Source } from 'wonka';\nimport { subscribe, take, filter, toPromise, pipe } from 'wonka';\nimport type { OperationResult, OperationResultSource } from '../types';\n\n/** Patches a `toPromise` method onto the `Source` passed to it.\n * @param source$ - the Wonka {@link Source} to patch.\n * @returns The passed `source$` with a patched `toPromise` method as a {@link PromisifiedSource}.\n * @internal\n */\nexport function withPromise<T extends OperationResult>(\n  _source$: Source<T>\n): OperationResultSource<T> {\n  const source$ = ((sink: Sink<T>) =>\n    _source$(sink)) as OperationResultSource<T>;\n  source$.toPromise = () =>\n    pipe(\n      source$,\n      filter(result => !result.stale && !result.hasNext),\n      take(1),\n      toPromise\n    );\n  source$.then = (onResolve, onReject) =>\n    source$.toPromise().then(onResolve, onReject);\n  source$.subscribe = onResult => subscribe(onResult)(source$);\n  return source$;\n}\n","import type {\n  AnyVariables,\n  GraphQLRequest,\n  Operation,\n  OperationContext,\n  OperationType,\n} from '../types';\n\n/** Creates a {@link Operation} from the given parameters.\n *\n * @param kind - The {@link OperationType} of GraphQL operation, i.e. `query`, `mutation`, or `subscription`.\n * @param request - The {@link GraphQLRequest} or {@link Operation} used as a template for the new `Operation`.\n * @param context - The {@link OperationContext} `context` data for the `Operation`.\n * @returns A new {@link Operation}.\n *\n * @remarks\n * This method is both used to create new {@link Operation | Operations} as well as copy and modify existing\n * operations. While it’s not required to use this function to copy an `Operation`, it is recommended, in case\n * additional dynamic logic is added to them in the future.\n *\n * Hint: When an {@link Operation} is passed to the `request` argument, the `context` argument does not have to be\n * a complete {@link OperationContext} and will instead be combined with passed {@link Operation.context}.\n *\n * @example\n * An example of copying an existing `Operation` to modify its `context`:\n *\n * ```ts\n * makeOperation(\n *   operation.kind,\n *   operation,\n *   { requestPolicy: 'cache-first' },\n * );\n * ```\n */\nfunction makeOperation<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables,\n>(\n  kind: OperationType,\n  request: GraphQLRequest<Data, Variables>,\n  context: OperationContext\n): Operation<Data, Variables>;\n\nfunction makeOperation<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables,\n>(\n  kind: OperationType,\n  request: Operation<Data, Variables>,\n  context?: Partial<OperationContext>\n): Operation<Data, Variables>;\n\nfunction makeOperation(kind, request, context) {\n  return {\n    ...request,\n    kind,\n    context: request.context\n      ? {\n          ...request.context,\n          ...context,\n        }\n      : context || request.context,\n  };\n}\n\nexport { makeOperation };\n\n/** Adds additional metadata to an `Operation`'s `context.meta` property while copying it.\n * @see {@link OperationDebugMeta} for more information on the {@link OperationContext.meta} property.\n */\nexport const addMetadata = (\n  operation: Operation,\n  meta: OperationContext['meta']\n) => {\n  return makeOperation(operation.kind, operation, {\n    meta: {\n      ...operation.context.meta,\n      ...meta,\n    },\n  });\n};\n","export * from './error';\nexport * from './request';\nexport * from './result';\nexport * from './variables';\nexport * from './collectTypenames';\nexport * from './formatDocument';\nexport * from './maskTypename';\nexport * from './streamUtils';\nexport * from './operation';\n\nexport const noop = () => {\n  /* noop */\n};\n","/* eslint-disable prefer-rest-params */\nimport { Kind } from '@0no-co/graphql.web';\nimport type { DocumentNode, DefinitionNode } from './utils/graphql';\nimport type { AnyVariables, TypedDocumentNode } from './types';\nimport { keyDocument, stringifyDocument } from './utils';\n\n/** A GraphQL parse function, which may be called as a tagged template literal, returning a parsed {@link DocumentNode}.\n *\n * @remarks\n * The `gql` tag or function is used to parse a GraphQL query document into a {@link DocumentNode}.\n *\n * When used as a tagged template, `gql` will automatically merge fragment definitions into the resulting\n * document and deduplicate them.\n *\n * It enforces that all fragments have a unique name. When fragments with different definitions share a name,\n * it will log a warning in development.\n *\n * Hint: It’s recommended to use this `gql` function over other GraphQL parse functions, since it puts the parsed\n * results directly into `@urql/core`’s internal caches and prevents further unnecessary work.\n *\n * @example\n * ```ts\n * const AuthorFragment = gql`\n *   fragment AuthorDisplayComponent on Author {\n *     id\n *     name\n *   }\n * `;\n *\n * const BookFragment = gql`\n *   fragment ListBookComponent on Book {\n *     id\n *     title\n *     author {\n *       ...AuthorDisplayComponent\n *     }\n *   }\n *\n *   ${AuthorFragment}\n * `;\n *\n * const BookQuery = gql`\n *   query Book($id: ID!) {\n *     book(id: $id) {\n *       ...BookFragment\n *     }\n *   }\n *\n *   ${BookFragment}\n * `;\n * ```\n */\nfunction gql<Data = any, Variables extends AnyVariables = AnyVariables>(\n  strings: TemplateStringsArray,\n  ...interpolations: Array<TypedDocumentNode | DocumentNode | string>\n): TypedDocumentNode<Data, Variables>;\n\nfunction gql<Data = any, Variables extends AnyVariables = AnyVariables>(\n  string: string\n): TypedDocumentNode<Data, Variables>;\n\nfunction gql(parts: string | TemplateStringsArray /* arguments */) {\n  const fragmentNames = new Map<string, string>();\n  const definitions: DefinitionNode[] = [];\n  const source: DocumentNode[] = [];\n\n  // Apply the entire tagged template body's definitions\n  let body: string = Array.isArray(parts) ? parts[0] : parts || '';\n  for (let i = 1; i < arguments.length; i++) {\n    const value = arguments[i];\n    if (value && value.definitions) {\n      source.push(value);\n    } else {\n      body += value;\n    }\n\n    body += arguments[0][i];\n  }\n\n  source.unshift(keyDocument(body));\n  for (const document of source) {\n    for (const definition of document.definitions) {\n      if (definition.kind === Kind.FRAGMENT_DEFINITION) {\n        const name = definition.name.value;\n        const value = stringifyDocument(definition);\n        // Fragments will be deduplicated according to this Map\n        if (!fragmentNames.has(name)) {\n          fragmentNames.set(name, value);\n          definitions.push(definition);\n        } else if (\n          process.env.NODE_ENV !== 'production' &&\n          fragmentNames.get(name) !== value\n        ) {\n          // Fragments with the same names is expected to have the same contents\n          console.warn(\n            '[WARNING: Duplicate Fragment] A fragment with name `' +\n              name +\n              '` already exists in this document.\\n' +\n              'While fragment names may not be unique across your source, each name must be unique per document.'\n          );\n        }\n      } else {\n        definitions.push(definition);\n      }\n    }\n  }\n\n  return keyDocument({\n    kind: Kind.DOCUMENT,\n    definitions,\n  });\n}\n\nexport { gql };\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { filter, map, merge, pipe, tap } from 'wonka';\n\nimport type { Client } from '../client';\nimport type { Exchange, Operation, OperationResult } from '../types';\n\nimport {\n  makeOperation,\n  addMetadata,\n  collectTypenames,\n  formatDocument,\n  makeResult,\n} from '../utils';\n\ntype ResultCache = Map<number, OperationResult>;\ntype OperationCache = Map<string, Set<number>>;\n\nconst shouldSkip = ({ kind }: Operation) =>\n  kind !== 'mutation' && kind !== 'query';\n\n/** Adds unique typenames to query (for invalidating cache entries) */\nexport const mapTypeNames = (operation: Operation): Operation => {\n  const query = formatDocument(operation.query);\n  if (query !== operation.query) {\n    const formattedOperation = makeOperation(operation.kind, operation);\n    formattedOperation.query = query;\n    return formattedOperation;\n  } else {\n    return operation;\n  }\n};\n\n/** Default document cache exchange.\n *\n * @remarks\n * The default document cache in `urql` avoids sending the same GraphQL request\n * multiple times by caching it using the {@link Operation.key}. It will invalidate\n * query results automatically whenever it sees a mutation responses with matching\n * `__typename`s in their responses.\n *\n * The document cache will get the introspected `__typename` fields by modifying\n * your GraphQL operation documents using the {@link formatDocument} utility.\n *\n * This automatic invalidation strategy can fail if your query or mutation don’t\n * contain matching typenames, for instance, because the query contained an\n * empty list.\n * You can manually add hints for this exchange by specifying a list of\n * {@link OperationContext.additionalTypenames} for queries and mutations that\n * should invalidate one another.\n *\n * @see {@link https://urql.dev/goto/docs/basics/document-caching} for more information on this cache.\n */\nexport const cacheExchange: Exchange = ({ forward, client, dispatchDebug }) => {\n  const resultCache: ResultCache = new Map();\n  const operationCache: OperationCache = new Map();\n\n  const isOperationCached = (operation: Operation) =>\n    operation.kind === 'query' &&\n    operation.context.requestPolicy !== 'network-only' &&\n    (operation.context.requestPolicy === 'cache-only' ||\n      resultCache.has(operation.key));\n\n  return ops$ => {\n    const cachedOps$ = pipe(\n      ops$,\n      filter(op => !shouldSkip(op) && isOperationCached(op)),\n      map(operation => {\n        const cachedResult = resultCache.get(operation.key);\n\n        dispatchDebug({\n          operation,\n          ...(cachedResult\n            ? {\n                type: 'cacheHit',\n                message: 'The result was successfully retried from the cache',\n              }\n            : {\n                type: 'cacheMiss',\n                message: 'The result could not be retrieved from the cache',\n              }),\n        });\n\n        let result: OperationResult =\n          cachedResult ||\n          makeResult(operation, {\n            data: null,\n          });\n\n        result = {\n          ...result,\n          operation: addMetadata(operation, {\n            cacheOutcome: cachedResult ? 'hit' : 'miss',\n          }),\n        };\n\n        if (operation.context.requestPolicy === 'cache-and-network') {\n          result.stale = true;\n          reexecuteOperation(client, operation);\n        }\n\n        return result;\n      })\n    );\n\n    const forwardedOps$ = pipe(\n      merge([\n        pipe(\n          ops$,\n          filter(op => !shouldSkip(op) && !isOperationCached(op)),\n          map(mapTypeNames)\n        ),\n        pipe(\n          ops$,\n          filter(op => shouldSkip(op))\n        ),\n      ]),\n      map(op => addMetadata(op, { cacheOutcome: 'miss' })),\n      filter(\n        op => op.kind !== 'query' || op.context.requestPolicy !== 'cache-only'\n      ),\n      forward,\n      tap(response => {\n        let { operation } = response;\n        if (!operation) return;\n\n        let typenames = operation.context.additionalTypenames || [];\n        // NOTE: For now, we only respect `additionalTypenames` from subscriptions to\n        // avoid unexpected breaking changes\n        // We'd expect live queries or other update mechanisms to be more suitable rather\n        // than using subscriptions as “signals” to reexecute queries. However, if they’re\n        // just used as signals, it’s intuitive to hook them up using `additionalTypenames`\n        if (response.operation.kind !== 'subscription') {\n          typenames = collectTypenames(response.data).concat(typenames);\n        }\n\n        // Invalidates the cache given a mutation's response\n        if (\n          response.operation.kind === 'mutation' ||\n          response.operation.kind === 'subscription'\n        ) {\n          const pendingOperations = new Set<number>();\n\n          dispatchDebug({\n            type: 'cacheInvalidation',\n            message: `The following typenames have been invalidated: ${typenames}`,\n            operation,\n            data: { typenames, response },\n          });\n\n          for (let i = 0; i < typenames.length; i++) {\n            const typeName = typenames[i];\n            let operations = operationCache.get(typeName);\n            if (!operations)\n              operationCache.set(typeName, (operations = new Set()));\n            for (const key of operations.values()) pendingOperations.add(key);\n            operations.clear();\n          }\n\n          for (const key of pendingOperations.values()) {\n            if (resultCache.has(key)) {\n              operation = (resultCache.get(key) as OperationResult).operation;\n              resultCache.delete(key);\n              reexecuteOperation(client, operation);\n            }\n          }\n        } else if (operation.kind === 'query' && response.data) {\n          resultCache.set(operation.key, response);\n          for (let i = 0; i < typenames.length; i++) {\n            const typeName = typenames[i];\n            let operations = operationCache.get(typeName);\n            if (!operations)\n              operationCache.set(typeName, (operations = new Set()));\n            operations.add(operation.key);\n          }\n        }\n      })\n    );\n\n    return merge([cachedOps$, forwardedOps$]);\n  };\n};\n\n/** Reexecutes an `Operation` with the `network-only` request policy.\n * @internal\n */\nexport const reexecuteOperation = (client: Client, operation: Operation) => {\n  return client.reexecuteOperation(\n    makeOperation(operation.kind, operation, {\n      requestPolicy: 'network-only',\n    })\n  );\n};\n","import type { GraphQLError } from '../utils/graphql';\nimport { pipe, filter, merge, map, tap } from 'wonka';\nimport type { Exchange, OperationResult, Operation } from '../types';\nimport { addMetadata, CombinedError } from '../utils';\nimport { reexecuteOperation, mapTypeNames } from './cache';\n\n/** A serialized version of an {@link OperationResult}.\n *\n * @remarks\n * All properties are serialized separately as JSON strings, except for the\n * {@link CombinedError} to speed up JS parsing speed, even if a result doesn’t\n * end up being used.\n *\n * @internal\n */\nexport interface SerializedResult {\n  hasNext?: boolean;\n  /** JSON-serialized version of {@link OperationResult.data}. */\n  data?: string | undefined; // JSON string of data\n  /** JSON-serialized version of {@link OperationResult.extensions}. */\n  extensions?: string | undefined;\n  /** JSON version of {@link CombinedError}. */\n  error?: {\n    graphQLErrors: Array<Partial<GraphQLError> | string>;\n    networkError?: string;\n  };\n}\n\n/** A dictionary of {@link Operation.key} keys to serializable {@link SerializedResult} objects.\n *\n * @remarks\n * It’s not recommended to modify the serialized data manually, however, multiple payloads of\n * this dictionary may safely be merged and combined.\n */\nexport interface SSRData {\n  [key: string]: SerializedResult;\n}\n\n/** Options for the `ssrExchange` allowing it to either operate on the server- or client-side. */\nexport interface SSRExchangeParams {\n  /** Indicates to the {@link SSRExchange} whether it's currently in server-side or client-side mode.\n   *\n   * @remarks\n   * Depending on this option, the {@link SSRExchange} will either capture or replay results.\n   * When `true`, it’s in client-side mode and results will be serialized. When `false`, it’ll\n   * use its deserialized data and replay results from it.\n   */\n  isClient?: boolean;\n  /** May be used on the client-side to pass the {@link SSRExchange} serialized data from the server-side.\n   *\n   * @remarks\n   * Alternatively, {@link SSRExchange.restoreData} may be called to imperatively add serialized data to\n   * the exchange.\n   *\n   * Hint: This method also works on the server-side to add to the initial serialized data, which enables\n   * you to combine multiple {@link SSRExchange} results, as needed.\n   */\n  initialState?: SSRData;\n  /** Forces a new API request to be sent in the background after replaying the deserialized result.\n   *\n   * @remarks\n   * Similarly to the `cache-and-network` {@link RequestPolicy}, this option tells the {@link SSRExchange}\n   * to send a new API request for the {@link Operation} after replaying a serialized result.\n   *\n   * Hint: This is useful when you're caching SSR results and need the client-side to update itself after\n   * rendering the initial serialized SSR results.\n   */\n  staleWhileRevalidate?: boolean;\n  /** Forces {@link OperationResult.extensions} to be serialized alongside the rest of a result.\n   *\n   * @remarks\n   * Entries in the `extension` object of a GraphQL result are often non-standard metdata, and many\n   * APIs use it for data that changes between every request. As such, the {@link SSRExchange} will\n   * not serialize this data by default, unless this flag is set.\n   */\n  includeExtensions?: boolean;\n}\n\n/** An `SSRExchange` either in server-side mode, serializing results, or client-side mode, deserializing and replaying results..\n *\n * @remarks\n * This same {@link Exchange} is used in your code both for the client-side and server-side as it’s “universal”\n * and can be put into either client-side or server-side mode using the {@link SSRExchangeParams.isClient} flag.\n *\n * In server-side mode, the `ssrExchange` will “record” results it sees from your API and provide them for you\n * to send to the client-side using the {@link SSRExchange.extractData} method.\n *\n * In client-side mode, the `ssrExchange` will use these serialized results, rehydrated either using\n * {@link SSRExchange.restoreData} or {@link SSRexchangeParams.initialState}, to replay results the\n * server-side has seen and sent before.\n *\n * Each serialized result will only be replayed once, as it’s assumed that your cache exchange will have the\n * results cached afterwards.\n */\nexport interface SSRExchange extends Exchange {\n  /** Client-side method to add serialized results to the {@link SSRExchange}.\n   * @param data - {@link SSRData},\n   */\n  restoreData(data: SSRData): void;\n  /** Server-side method to get all serialized results the {@link SSRExchange} has captured.\n   * @returns an {@link SSRData} dictionary.\n   */\n  extractData(): SSRData;\n}\n\n/** Serialize an OperationResult to plain JSON */\nconst serializeResult = (\n  result: OperationResult,\n  includeExtensions: boolean\n): SerializedResult => {\n  const serialized: SerializedResult = {\n    data: JSON.stringify(result.data),\n    hasNext: result.hasNext,\n  };\n\n  if (result.data !== undefined) {\n    serialized.data = JSON.stringify(result.data);\n  }\n\n  if (includeExtensions && result.extensions !== undefined) {\n    serialized.extensions = JSON.stringify(result.extensions);\n  }\n\n  if (result.error) {\n    serialized.error = {\n      graphQLErrors: result.error.graphQLErrors.map(error => {\n        if (!error.path && !error.extensions) return error.message;\n\n        return {\n          message: error.message,\n          path: error.path,\n          extensions: error.extensions,\n        };\n      }),\n    };\n\n    if (result.error.networkError) {\n      serialized.error.networkError = '' + result.error.networkError;\n    }\n  }\n\n  return serialized;\n};\n\n/** Deserialize plain JSON to an OperationResult\n * @internal\n */\nconst deserializeResult = (\n  operation: Operation,\n  result: SerializedResult,\n  includeExtensions: boolean\n): OperationResult => ({\n  operation,\n  data: result.data ? JSON.parse(result.data) : undefined,\n  extensions:\n    includeExtensions && result.extensions\n      ? JSON.parse(result.extensions)\n      : undefined,\n  error: result.error\n    ? new CombinedError({\n        networkError: result.error.networkError\n          ? new Error(result.error.networkError)\n          : undefined,\n        graphQLErrors: result.error.graphQLErrors,\n      })\n    : undefined,\n  stale: false,\n  hasNext: !!result.hasNext,\n});\n\nconst revalidated = new Set<number>();\n\n/** Creates a server-side rendering `Exchange` that either captures responses on the server-side or replays them on the client-side.\n *\n * @param params - An {@link SSRExchangeParams} configuration object.\n * @returns the created {@link SSRExchange}\n *\n * @remarks\n * When dealing with server-side rendering, we essentially have two {@link Client | Clients} making requests,\n * the server-side client, and the client-side one. The `ssrExchange` helps implementing a tiny cache on both\n * sides that:\n *\n * - captures results on the server-side which it can serialize,\n * - replays results on the client-side that it deserialized from the server-side.\n *\n * Hint: The `ssrExchange` is basically an exchange that acts like a replacement for any fetch exchange\n * temporarily. As such, you should place it after your cache exchange but in front of any fetch exchange.\n */\nexport const ssrExchange = (params: SSRExchangeParams = {}): SSRExchange => {\n  const staleWhileRevalidate = !!params.staleWhileRevalidate;\n  const includeExtensions = !!params.includeExtensions;\n  const data: Record<string, SerializedResult | null> = {};\n\n  // On the client-side, we delete results from the cache as they're resolved\n  // this is delayed so that concurrent queries don't delete each other's data\n  const invalidateQueue: number[] = [];\n  const invalidate = (result: OperationResult) => {\n    invalidateQueue.push(result.operation.key);\n    if (invalidateQueue.length === 1) {\n      Promise.resolve().then(() => {\n        let key: number | void;\n        while ((key = invalidateQueue.shift())) {\n          data[key] = null;\n        }\n      });\n    }\n  };\n\n  // The SSR Exchange is a temporary cache that can populate results into data for suspense\n  // On the client it can be used to retrieve these temporary results from a rehydrated cache\n  const ssr: SSRExchange =\n    ({ client, forward }) =>\n    ops$ => {\n      // params.isClient tells us whether we're on the client-side\n      // By default we assume that we're on the client if suspense-mode is disabled\n      const isClient =\n        params && typeof params.isClient === 'boolean'\n          ? !!params.isClient\n          : !client.suspense;\n\n      let forwardedOps$ = pipe(\n        ops$,\n        filter(\n          operation =>\n            operation.kind === 'teardown' ||\n            !data[operation.key] ||\n            !!data[operation.key]!.hasNext ||\n            operation.context.requestPolicy === 'network-only'\n        ),\n        map(mapTypeNames),\n        forward\n      );\n\n      // NOTE: Since below we might delete the cached entry after accessing\n      // it once, cachedOps$ needs to be merged after forwardedOps$\n      let cachedOps$ = pipe(\n        ops$,\n        filter(\n          operation =>\n            operation.kind !== 'teardown' &&\n            !!data[operation.key] &&\n            operation.context.requestPolicy !== 'network-only'\n        ),\n        map(op => {\n          const serialized = data[op.key]!;\n          const cachedResult = deserializeResult(\n            op,\n            serialized,\n            includeExtensions\n          );\n\n          if (staleWhileRevalidate && !revalidated.has(op.key)) {\n            cachedResult.stale = true;\n            revalidated.add(op.key);\n            reexecuteOperation(client, op);\n          }\n\n          const result: OperationResult = {\n            ...cachedResult,\n            operation: addMetadata(op, {\n              cacheOutcome: 'hit',\n            }),\n          };\n          return result;\n        })\n      );\n\n      if (!isClient) {\n        // On the server we cache results in the cache as they're resolved\n        forwardedOps$ = pipe(\n          forwardedOps$,\n          tap((result: OperationResult) => {\n            const { operation } = result;\n            if (operation.kind !== 'mutation') {\n              const serialized = serializeResult(result, includeExtensions);\n              data[operation.key] = serialized;\n            }\n          })\n        );\n      } else {\n        // On the client we delete results from the cache as they're resolved\n        cachedOps$ = pipe(cachedOps$, tap(invalidate));\n      }\n\n      return merge([forwardedOps$, cachedOps$]);\n    };\n\n  ssr.restoreData = (restore: SSRData) => {\n    for (const key in restore) {\n      // We only restore data that hasn't been previously invalidated\n      if (data[key] !== null) {\n        data[key] = restore[key];\n      }\n    }\n  };\n\n  ssr.extractData = () => {\n    const result: SSRData = {};\n    for (const key in data) if (data[key] != null) result[key] = data[key]!;\n    return result;\n  };\n\n  if (params && params.initialState) {\n    ssr.restoreData(params.initialState);\n  }\n\n  return ssr;\n};\n","import type { Subscription, Source } from 'wonka';\nimport { filter, make, merge, mergeMap, pipe, takeUntil } from 'wonka';\n\nimport {\n  makeResult,\n  mergeResultPatch,\n  makeErrorResult,\n  makeOperation,\n} from '../utils';\n\nimport type {\n  Exchange,\n  ExecutionResult,\n  Operation,\n  OperationResult,\n} from '../types';\n\nimport type { FetchBody } from '../internal';\nimport { makeFetchBody } from '../internal';\n\n/** An abstract observer-like interface.\n *\n * @remarks\n * Observer-like interfaces are passed to {@link ObservableLike.subscribe} to provide them\n * with callbacks for their events.\n *\n * @see {@link https://github.com/tc39/proposal-observable} for the full TC39 Observable proposal.\n */\nexport interface ObserverLike<T> {\n  /** Callback for values an {@link ObservableLike} emits. */\n  next: (value: T) => void;\n  /** Callback for an error an {@link ObservableLike} emits, which ends the subscription. */\n  error: (err: any) => void;\n  /** Callback for the completion of an {@link ObservableLike}, which ends the subscription. */\n  complete: () => void;\n}\n\n/** An abstract observable-like interface.\n *\n * @remarks\n * Observable, or Observable-like interfaces, are often used by GraphQL transports to abstract\n * how they send {@link ExecutionResult | ExecutionResults} to consumers. These generally contain\n * a `subscribe` method accepting an {@link ObserverLike} structure.\n *\n * @see {@link https://github.com/tc39/proposal-observable} for the full TC39 Observable proposal.\n */\nexport interface ObservableLike<T> {\n  /** Start the Observable-like subscription and returns a subscription handle.\n   *\n   * @param observer - an {@link ObserverLike} object with result, error, and completion callbacks.\n   * @returns a subscription handle providing an `unsubscribe` method to stop the subscription.\n   */\n  subscribe(observer: ObserverLike<T>): {\n    unsubscribe: () => void;\n  };\n}\n\n/** A more cross-compatible version of the {@link GraphQLRequest} structure.\n * {@link FetchBody} for more details\n */\nexport type SubscriptionOperation = FetchBody;\n\n/** A subscription forwarding function, which must accept a {@link SubscriptionOperation}.\n *\n * @param operation - A {@link SubscriptionOperation}\n * @returns An {@link ObservableLike} object issuing {@link ExecutionResult | ExecutionResults}.\n */\nexport type SubscriptionForwarder = (\n  request: FetchBody,\n  operation: Operation\n) => ObservableLike<ExecutionResult>;\n\n/** This is called to create a subscription and needs to be hooked up to a transport client. */\nexport interface SubscriptionExchangeOpts {\n  /** A subscription forwarding function, which must accept a {@link SubscriptionOperation}.\n   *\n   * @param operation - A {@link SubscriptionOperation}\n   * @returns An {@link ObservableLike} object issuing {@link ExecutionResult | ExecutionResults}.\n   *\n   * @remarks\n   * This callback is called for each {@link Operation} that this `subscriptionExchange` will\n   * handle. It receives the {@link SubscriptionOperation}, which is a more compatible version\n   * of the raw {@link Operation} objects and must return an {@link ObservableLike} of results.\n   */\n  forwardSubscription: SubscriptionForwarder;\n\n  /** Flag to enable this exchange to handle all types of GraphQL operations.\n   *\n   * @remarks\n   * When you aren’t using fetch exchanges and GraphQL over HTTP as a transport for your GraphQL requests,\n   * or you have a third-party GraphQL transport implementation, which must also be used for queries and\n   * mutations, this flag may be used to allow this exchange to handle all kinds of GraphQL operations.\n   *\n   * By default, this flag is `false` and the exchange will only handle GraphQL subscription operations.\n   */\n  enableAllOperations?: boolean;\n\n  /** A predicate function that causes an operation to be handled by this `subscriptionExchange` if `true` is returned.\n   *\n   * @param operation - an {@link Operation}\n   * @returns true when the operation is handled by this exchange.\n   *\n   * @remarks\n   * In some cases, a `subscriptionExchange` will be used to only handle some {@link Operation | Operations},\n   * e.g. all that contain `@live` directive. For these cases, this function may be passed to precisely\n   * determine which `Operation`s this exchange should handle, instead of forwarding.\n   *\n   * When specified, the {@link SubscriptionExchangeOpts.enableAllOperations} flag is disregarded.\n   */\n  isSubscriptionOperation?: (operation: Operation) => boolean;\n}\n\n/** Generic subscription exchange factory used to either create an exchange handling just subscriptions or all operation kinds.\n *\n * @remarks\n * `subscriptionExchange` can be used to create an {@link Exchange} that either\n * handles just GraphQL subscription operations, or optionally all operations,\n * when the {@link SubscriptionExchangeOpts.enableAllOperations} flag is passed.\n *\n * The {@link SubscriptionExchangeOpts.forwardSubscription} function must\n * be provided and provides a generic input that's based on {@link Operation}\n * but is compatible with many libraries implementing GraphQL request or\n * subscription interfaces.\n */\nexport const subscriptionExchange =\n  ({\n    forwardSubscription,\n    enableAllOperations,\n    isSubscriptionOperation,\n  }: SubscriptionExchangeOpts): Exchange =>\n  ({ client, forward }) => {\n    const createSubscriptionSource = (\n      operation: Operation\n    ): Source<OperationResult> => {\n      const observableish = forwardSubscription(\n        makeFetchBody(operation),\n        operation\n      );\n\n      return make<OperationResult>(observer => {\n        let isComplete = false;\n        let sub: Subscription | void;\n        let result: OperationResult | void;\n\n        function nextResult(value: ExecutionResult) {\n          observer.next(\n            (result = result\n              ? mergeResultPatch(result, value)\n              : makeResult(operation, value))\n          );\n        }\n\n        Promise.resolve().then(() => {\n          if (isComplete) return;\n\n          sub = observableish.subscribe({\n            next: nextResult,\n            error(error) {\n              if (Array.isArray(error)) {\n                // NOTE: This is an exception for transports that deliver `GraphQLError[]`, as part\n                // of the observer’s error callback (may happen as part of `graphql-ws`).\n                // We only check for arrays here, as this is an extremely “unexpected” case as the\n                // shape of `ExecutionResult` is instead strictly defined.\n                nextResult({ errors: error });\n              } else {\n                observer.next(makeErrorResult(operation, error));\n              }\n              observer.complete();\n            },\n            complete() {\n              if (!isComplete) {\n                isComplete = true;\n                if (operation.kind === 'subscription') {\n                  client.reexecuteOperation(\n                    makeOperation('teardown', operation, operation.context)\n                  );\n                }\n                if (result && result.hasNext) {\n                  nextResult({ hasNext: false });\n                }\n                observer.complete();\n              }\n            },\n          });\n        });\n\n        return () => {\n          isComplete = true;\n          if (sub) sub.unsubscribe();\n        };\n      });\n    };\n\n    const isSubscriptionOperationFn =\n      isSubscriptionOperation ||\n      (operation =>\n        operation.kind === 'subscription' ||\n        (!!enableAllOperations &&\n          (operation.kind === 'query' || operation.kind === 'mutation')));\n\n    return ops$ => {\n      const subscriptionResults$ = pipe(\n        ops$,\n        filter(\n          operation =>\n            operation.kind !== 'teardown' &&\n            isSubscriptionOperationFn(operation)\n        ),\n        mergeMap(operation => {\n          const { key } = operation;\n          const teardown$ = pipe(\n            ops$,\n            filter(op => op.kind === 'teardown' && op.key === key)\n          );\n\n          return pipe(\n            createSubscriptionSource(operation),\n            takeUntil(teardown$)\n          );\n        })\n      );\n\n      const forward$ = pipe(\n        ops$,\n        filter(\n          operation =>\n            operation.kind === 'teardown' ||\n            !isSubscriptionOperationFn(operation)\n        ),\n        forward\n      );\n\n      return merge([subscriptionResults$, forward$]);\n    };\n  };\n","import { pipe, tap } from 'wonka';\nimport type { Exchange } from '../types';\n\n/** Simple log debugger exchange.\n *\n * @remarks\n * An exchange that logs incoming {@link Operation | Operations} and\n * {@link OperationResult | OperationResults} in development.\n *\n * This exchange is a no-op in production and often used in issue reporting\n * to understand certain usage patterns of `urql` without having access to\n * the original source code.\n *\n * Hint: When you report an issue you’re having with `urql`, adding\n * this as your first exchange and posting its output can speed up\n * issue triaging a lot!\n */\nexport const debugExchange: Exchange = ({ forward }) => {\n  if (process.env.NODE_ENV === 'production') {\n    return ops$ => forward(ops$);\n  } else {\n    return ops$ =>\n      pipe(\n        ops$,\n        // eslint-disable-next-line no-console\n        tap(op => console.log('[Exchange debug]: Incoming operation: ', op)),\n        forward,\n        tap(result =>\n          // eslint-disable-next-line no-console\n          console.log('[Exchange debug]: Completed operation: ', result)\n        )\n      );\n  }\n};\n","import type { Exchange } from '../types';\n\n/** Default deduplication exchange.\n * @deprecated\n * This exchange's functionality is now built into the {@link Client}.\n */\nexport const dedupExchange: Exchange =\n  ({ forward }) =>\n  ops$ =>\n    forward(ops$);\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { filter, merge, mergeMap, pipe, takeUntil, onPush } from 'wonka';\n\nimport type { Exchange } from '../types';\nimport {\n  makeFetchBody,\n  makeFetchURL,\n  makeFetchOptions,\n  makeFetchSource,\n} from '../internal';\n\n/** Default GraphQL over HTTP fetch exchange.\n *\n * @remarks\n * The default fetch exchange in `urql` supports sending GraphQL over HTTP\n * requests, can optionally send GraphQL queries as GET requests, and\n * handles incremental multipart responses.\n *\n * This exchange does not handle persisted queries or multipart uploads.\n * Support for the former can be added using `@urql/exchange-persisted-fetch`\n * and the latter using `@urql/exchange-multipart-fetch`.\n *\n * Hint: The `fetchExchange` and the two other exchanges all use the built-in fetch\n * utilities in `@urql/core/internal`, which you can also use to implement\n * a customized fetch exchange.\n *\n * @see {@link makeFetchSource} for the shared utility calling the Fetch API.\n */\nexport const fetchExchange: Exchange = ({ forward, dispatchDebug }) => {\n  return ops$ => {\n    const fetchResults$ = pipe(\n      ops$,\n      filter(operation => {\n        return (\n          operation.kind !== 'teardown' &&\n          (operation.kind !== 'subscription' ||\n            !!operation.context.fetchSubscriptions)\n        );\n      }),\n      mergeMap(operation => {\n        const body = makeFetchBody(operation);\n        const url = makeFetchURL(operation, body);\n        const fetchOptions = makeFetchOptions(operation, body);\n\n        dispatchDebug({\n          type: 'fetchRequest',\n          message: 'A fetch request is being executed.',\n          operation,\n          data: {\n            url,\n            fetchOptions,\n          },\n        });\n\n        const source = pipe(\n          makeFetchSource(operation, url, fetchOptions),\n          takeUntil(\n            pipe(\n              ops$,\n              filter(op => op.kind === 'teardown' && op.key === operation.key)\n            )\n          )\n        );\n\n        if (process.env.NODE_ENV !== 'production') {\n          return pipe(\n            source,\n            onPush(result => {\n              const error = !result.data ? result.error : undefined;\n\n              dispatchDebug({\n                type: error ? 'fetchError' : 'fetchSuccess',\n                message: `A ${\n                  error ? 'failed' : 'successful'\n                } fetch response has been returned.`,\n                operation,\n                data: {\n                  url,\n                  fetchOptions,\n                  value: error || result,\n                },\n              });\n            })\n          );\n        }\n\n        return source;\n      })\n    );\n\n    const forward$ = pipe(\n      ops$,\n      filter(operation => {\n        return (\n          operation.kind === 'teardown' ||\n          (operation.kind === 'subscription' &&\n            !operation.context.fetchSubscriptions)\n        );\n      }),\n      forward\n    );\n\n    return merge([fetchResults$, forward$]);\n  };\n};\n","import { share } from 'wonka';\nimport type { ExchangeIO, Exchange, ExchangeInput } from '../types';\n\n/** Composes an array of Exchanges into a single one.\n *\n * @param exchanges - An array of {@link Exchange | Exchanges}.\n * @returns - A composed {@link Exchange}.\n *\n * @remarks\n * `composeExchanges` returns an {@link Exchange} that when instantiated\n * composes the array of passed `Exchange`s into one, calling them from\n * right to left, with the prior `Exchange`’s {@link ExchangeIO} function\n * as the {@link ExchangeInput.forward} input.\n *\n * This simply merges all exchanges into one and is used by the {@link Client}\n * to merge the `exchanges` option it receives.\n *\n * @throws\n * In development, if {@link ExchangeInput.forward} is called repeatedly\n * by an {@link Exchange} an error is thrown, since `forward()` must only\n * be called once per `Exchange`.\n */\nexport const composeExchanges =\n  (exchanges: Exchange[]): Exchange =>\n  ({ client, forward, dispatchDebug }: ExchangeInput): ExchangeIO =>\n    exchanges.reduceRight((forward, exchange) => {\n      let forwarded = false;\n      return exchange({\n        client,\n        forward(operations$) {\n          if (process.env.NODE_ENV !== 'production') {\n            if (forwarded)\n              throw new Error(\n                'forward() must only be called once in each Exchange.'\n              );\n            forwarded = true;\n          }\n          return share(forward(share(operations$)));\n        },\n        dispatchDebug(event) {\n          dispatchDebug({\n            timestamp: Date.now(),\n            source: exchange.name,\n            ...event,\n          });\n        },\n      });\n    }, forward);\n","import { mergeMap, fromValue, fromPromise, pipe } from 'wonka';\nimport type { Operation, OperationResult, Exchange } from '../types';\nimport type { CombinedError } from '../utils';\n\n/** Options for the `mapExchange` allowing it to react to incoming operations, results, or errors. */\nexport interface MapExchangeOpts {\n  /** Accepts a callback for incoming `Operation`s.\n   *\n   * @param operation - An {@link Operation} that the {@link mapExchange} received.\n   * @returns optionally a new {@link Operation} replacing the original.\n   *\n   * @remarks\n   * You may return new {@link Operation | Operations} from this function replacing\n   * the original that the {@link mapExchange} received.\n   * It’s recommended that you use the {@link makeOperation} utility to create a copy\n   * of the original when you do this. (However, this isn’t required)\n   *\n   * Hint: The callback may also be promisified and return a new {@link Operation} asynchronously,\n   * provided you place your {@link mapExchange} after all synchronous {@link Exchange | Exchanges},\n   * like after your `cacheExchange`.\n   */\n  onOperation?(operation: Operation): Promise<Operation> | Operation | void;\n  /** Accepts a callback for incoming `OperationResult`s.\n   *\n   * @param result - An {@link OperationResult} that the {@link mapExchange} received.\n   * @returns optionally a new {@link OperationResult} replacing the original.\n   *\n   * @remarks\n   * This callback may optionally return a new {@link OperationResult} that replaces the original,\n   * which you can use to modify incoming API results.\n   *\n   * Hint: The callback may also be promisified and return a new {@link Operation} asynchronously,\n   * provided you place your {@link mapExchange} after all synchronous {@link Exchange | Exchanges},\n   * like after your `cacheExchange`.\n   */\n  onResult?(\n    result: OperationResult\n  ): Promise<OperationResult> | OperationResult | void;\n  /** Accepts a callback for incoming `CombinedError`s.\n   *\n   * @param error - A {@link CombinedError} that an incoming {@link OperationResult} contained.\n   * @param operation - The {@link Operation} of the incoming {@link OperationResult}.\n   *\n   * @remarks\n   * The callback may also be promisified and return a new {@link Operation} asynchronously,\n   * provided you place your {@link mapExchange} after all synchronous {@link Exchange | Exchanges},\n   * like after your `cacheExchange`.\n   */\n  onError?(error: CombinedError, operation: Operation): void;\n}\n\n/** Creates an `Exchange` mapping over incoming operations, results, and/or errors.\n *\n * @param opts - A {@link MapExchangeOpts} configuration object, containing the callbacks the `mapExchange` will use.\n * @returns the created {@link Exchange}\n *\n * @remarks\n * The `mapExchange` may be used to react to or modify incoming {@link Operation | Operations}\n * and {@link OperationResult | OperationResults}. Optionally, it can also modify these\n * asynchronously, when a promise is returned from the callbacks.\n *\n * This is useful to, for instance, add an authentication token to a given request, when\n * the `@urql/exchange-auth` package would be overkill.\n *\n * It can also accept an `onError` callback, which can be used to react to incoming\n * {@link CombinedError | CombinedErrors} on results, and trigger side-effects.\n *\n */\nexport const mapExchange = ({\n  onOperation,\n  onResult,\n  onError,\n}: MapExchangeOpts): Exchange => {\n  return ({ forward }) =>\n    ops$ => {\n      return pipe(\n        pipe(\n          ops$,\n          mergeMap(operation => {\n            const newOperation =\n              (onOperation && onOperation(operation)) || operation;\n            return 'then' in newOperation\n              ? fromPromise(newOperation)\n              : fromValue(newOperation);\n          })\n        ),\n        forward,\n        mergeMap(result => {\n          if (onError && result.error) onError(result.error, result.operation);\n          const newResult = (onResult && onResult(result)) || result;\n          return 'then' in newResult\n            ? fromPromise(newResult)\n            : fromValue(newResult);\n        })\n      );\n    };\n};\n","import { filter, pipe, tap } from 'wonka';\nimport type { ExchangeIO, ExchangeInput } from '../types';\n\n/** Used by the `Client` as the last exchange to warn about unhandled operations.\n *\n * @remarks\n * In a normal setup, some operations may go unhandled when a {@link Client} isn’t set up\n * with the right exchanges.\n * For instance, a `Client` may be missing a fetch exchange, or an exchange handling subscriptions.\n * This {@link Exchange} is added by the `Client` automatically to log warnings about unhandled\n * {@link Operaiton | Operations} in development.\n */\nexport const fallbackExchange: ({\n  dispatchDebug,\n}: Pick<ExchangeInput, 'dispatchDebug'>) => ExchangeIO =\n  ({ dispatchDebug }) =>\n  ops$ => {\n    if (process.env.NODE_ENV !== 'production') {\n      ops$ = pipe(\n        ops$,\n        tap(operation => {\n          if (\n            operation.kind !== 'teardown' &&\n            process.env.NODE_ENV !== 'production'\n          ) {\n            const message = `No exchange has handled operations of kind \"${operation.kind}\". Check whether you've added an exchange responsible for these operations.`;\n\n            dispatchDebug({\n              type: 'fallbackCatch',\n              message,\n              operation,\n            });\n            console.warn(message);\n          }\n        })\n      );\n    }\n\n    // All operations that skipped through the entire exchange chain should be filtered from the output\n    return filter((_x): _x is never => false)(ops$);\n  };\n","/* eslint-disable @typescript-eslint/no-use-before-define */\n\nimport type { Source, Subscription } from 'wonka';\nimport {\n  lazy,\n  filter,\n  makeSubject,\n  onEnd,\n  onPush,\n  onStart,\n  pipe,\n  share,\n  take,\n  takeUntil,\n  takeWhile,\n  publish,\n  subscribe,\n  switchMap,\n  fromValue,\n  merge,\n  map,\n} from 'wonka';\n\nimport { composeExchanges } from './exchanges';\nimport { fallbackExchange } from './exchanges/fallback';\n\nimport type {\n  DocumentInput,\n  AnyVariables,\n  Exchange,\n  ExchangeInput,\n  GraphQLRequest,\n  Operation,\n  OperationInstance,\n  OperationContext,\n  OperationResult,\n  OperationResultSource,\n  OperationType,\n  RequestPolicy,\n  DebugEvent,\n} from './types';\n\nimport {\n  createRequest,\n  withPromise,\n  maskTypename,\n  noop,\n  makeOperation,\n  getOperationType,\n} from './utils';\n\n/** Configuration options passed when creating a new {@link Client}.\n *\n * @remarks\n * The `ClientOptions` are passed when creating a new {@link Client}, and\n * are used to instantiate the pipeline of {@link Exchange | Exchanges}, configure\n * options used to initialize {@link OperationContext | OperationContexts}, or to\n * change the general behaviour of the {@link Client}.\n */\nexport interface ClientOptions {\n  /** Target URL used by fetch exchanges to make GraphQL API requests to.\n   *\n   * @remarks\n   * This is the URL that fetch exchanges will call to make GraphQL API requests.\n   * This value is copied to {@link OperationContext.url}.\n   */\n  url: string;\n  /** Additional options used by fetch exchanges that'll be passed to the `fetch` call on API requests.\n   *\n   * @remarks\n   * The options in this object or an object returned by a callback function will be merged into the\n   * {@link RequestInit} options passed to the `fetch` call.\n   *\n   * Hint: If you're trying to implement more complex changes per {@link Operation}, it's worth considering\n   * to use the {@link mapExchange} instead, which allows you to change `Operation`s and `OperationResult`s.\n   *\n   * Hint: If you're trying to use this as a function for authentication, consider checking out\n   * `@urql/exchange-auth` instead, which allows you to handle refresh auth flows, and more\n   * complex auth flows.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/fetch} for a description of this object.\n   */\n  fetchOptions?: RequestInit | (() => RequestInit);\n  /** A `fetch` function polyfill used by fetch exchanges to make API calls.\n   *\n   * @remarks\n   * This is the fetch polyfill used by any fetch exchange to make an API request. By default, when this\n   * option isn't set, any fetch exchange will attempt to use the globally available `fetch` function\n   * to make a request instead.\n   *\n   * It's recommended to only pass a polyfill, if any of the environments you're running the {@link Client}\n   * in don't support the Fetch API natively.\n   *\n   * Hint: If you're using the \"Incremental Delivery\" multipart spec, for instance with `@defer` directives,\n   * you're better off using the native `fetch` function, or must ensure that your polyfill supports streamed\n   * results. However, a \"Streaming requests unsupported\" error will be thrown, to let you know that your `fetch`\n   * API doesn't support incrementally streamed responses, if this mode is used.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API} for the Fetch API spec.\n   */\n  fetch?: typeof fetch;\n  /** Allows a subscription to be executed using a `fetch` API request.\n   *\n   * @remarks\n   * If your API supports the `text/event-stream` and/or `multipart/mixed` response protocol, and you use\n   * this protocol to handle subscriptions, then you may switch this flag to `true`.\n   *\n   * This means you won’t have to create a {@link subscriptionExchange} to handle subscriptions with an\n   * external transport, and will instead be able to use GraphQL over HTTP transports.\n   */\n  fetchSubscriptions?: boolean;\n  /** A list of `Exchange`s that will be used to create the `Client`'s execution pipeline.\n   *\n   * @remarks\n   * The {@link Client} accepts and composes a list of {@link Exchange | Exchanges} into an “exchange pipeline”\n   * which receive a stream of {@link Operation | Operations} the `Client` wishes to execute, and return a stream\n   * of {@link OperationResult | OperationResults}.\n   *\n   * This is the basis for how `urql` handles GraphQL operations, and exchanges handle the creation, execution,\n   * and control flow of exchanges for the `Client`.\n   *\n   * To easily get started you should consider using the {@link dedupExchange}, {@link cacheExchange} and {@link fetchExchange}\n   * these are all exported from the core package.\n   *\n   * @see {@link https://urql.dev/goto/docs/architecture/#the-client-and-exchanges} for more information\n   * on what `Exchange`s are and how they work.\n   */\n  exchanges: Exchange[];\n  /** A configuration flag indicating whether support for \"Suspense\" is activated.\n   *\n   * @remarks\n   * This configuration flag is only relevant for using `urql` with the React or Preact bindings.\n   * When activated it allows `useQuery` to \"suspend\" instead of returning a loading state, which\n   * will stop updates in a querying component and instead cascade\n   * to a higher suspense boundary for a loading state.\n   *\n   * Hint: While, when this option is enabled, by default all `useQuery` hooks will suspense, you can\n   * disable Suspense selectively for each hook.\n   *\n   * @see {@link https://beta.reactjs.org/blog/2022/03/29/react-v18#new-suspense-features} for more information on React Suspense.\n   */\n  suspense?: boolean;\n  /** The request and caching strategy that all `Operation`s on this `Client` will use by default.\n   *\n   * @remarks\n   * The {@link RequestPolicy} instructs cache exchanges how to use and treat their cached results.\n   * By default `cache-first` is set and used, which will use cache results, and only make an API request\n   * on a cache miss.\n   *\n   * The `requestPolicy` can be overriden per operation, since it's added to the {@link OperationContext},\n   * which allows you to change the policy per `Operation`, rather than changing it by default here.\n   *\n   * Hint: We don’t recommend changing this from the default `cache-first` option, unless you know what\n   * you‘re doing. Setting this to `cache-and-network` is not recommend and may not lead to the behaviour\n   * you expect. If you’re looking to always update your cache frequently, use `@urql/exchange-request-policy`\n   * instead.\n   */\n  requestPolicy?: RequestPolicy;\n  /** Instructs fetch exchanges to use a GET request.\n   *\n   * @remarks\n   * This changes the {@link OperationContext.preferGetMethod} option, which tells fetch exchanges\n   * to use GET requests for queries instead of POST requests.\n   *\n   * When set to `true` or `'within-url-limit'`, built-in fetch exchanges will always attempt to send query\n   * operations as GET requests, unless the resulting URL exceeds a length of 2,048 characters.\n   * If you want to bypass this restriction, set this option to `'force'` instead, to always send GET.\n   * requests for queries.\n   */\n  preferGetMethod?: boolean | 'force' | 'within-url-limit';\n  /** Instructs the `Client` to remove `__typename` properties on all results.\n   *\n   * @deprecated Not recommended over modelling inputs manually (See #3299)\n   *\n   * @remarks\n   * By default, cache exchanges will alter your GraphQL documents to request `__typename` fields\n   * for all selections. However, this means that your GraphQL data will now contain `__typename` fields you\n   * didn't ask for. This is why the {@link Client} supports “masking” this field by marking it\n   * as non-enumerable via this option.\n   *\n   * Only use this option if you absolutely have to. It's popular to model mutation inputs in\n   * GraphQL schemas after the object types they modify, and if you're using this option to make\n   * it possible to directly pass objects from results as inputs to your mutation variables, it's\n   * more performant and idomatic to instead create a new input object.\n   *\n   * Hint: With `@urql/exchange-graphcache` you will never need this option, as it selects fields on\n   * the client-side according to which fields you specified, rather than the fields it modified.\n   *\n   * @see {@link https://spec.graphql.org/October2021/#sec-Type-Name-Introspection} for more information\n   * on typename introspection via the `__typename` field.\n   */\n  maskTypename?: boolean;\n}\n\n/** The `Client` is the central hub for your GraphQL operations and holds `urql`'s state.\n *\n * @remarks\n * The `Client` manages your active GraphQL operations and their state, and contains the\n * {@link Exchange} pipeline to execute your GraphQL operations.\n *\n * It contains methods that allow you to execute GraphQL operations manually, but the `Client`\n * is also interacted with by bindings (for React, Preact, Vue, Svelte, etc) to execute GraphQL\n * operations.\n *\n * While {@link Exchange | Exchanges} are ultimately responsible for the control flow of operations,\n * sending API requests, and caching, the `Client` still has the important responsibility for\n * creating operations, managing consumers of active operations, sharing results for operations,\n * and more tasks as a “central hub”.\n *\n * @see {@link https://urql.dev/goto/docs/architecture/#requests-and-operations-on-the-client} for more information\n * on what the `Client` is and does.\n */\nexport interface Client {\n  new (options: ClientOptions): Client;\n\n  /** Exposes the stream of `Operation`s that is passed to the `Exchange` pipeline.\n   *\n   * @remarks\n   * This is a Wonka {@link Source} that issues the {@link Operation | Operations} going into\n   * the exchange pipeline.\n   * @internal\n   */\n  operations$: Source<Operation>;\n\n  /** Flag indicating whether support for “Suspense” is activated.\n   *\n   * @remarks\n   * This flag indicates whether support for “Suspense” has been activated via the\n   * {@link ClientOptions.suspense} flag.\n   *\n   * When this is enabled, the {@link Client} itself doesn’t function any differently, and the flag\n   * only serves as an instructions for the React/Preact bindings to change their behaviour.\n   *\n   * @see {@link ClientOptions.suspense} for more information.\n   * @internal\n   */\n  suspense: boolean;\n\n  /** Dispatches an `Operation` to the `Exchange` pipeline, if this `Operation` is active.\n   *\n   * @remarks\n   * This method is frequently used in {@link Exchange | Exchanges}, for instance caches, to reexecute\n   * an operation. It’s often either called because an `Operation` will need to be queried against the\n   * cache again, if a cache result has changed or been invalidated, or it’s called with an {@link Operation}'s\n   * {@link RequestPolicy} set to `network-only` to issue a network request.\n   *\n   * This method will only dispatch an {@link Operation} if it has active consumers, meaning,\n   * active subscribers to the sources of {@link OperationResult}. For instance, if no bindings\n   * (e.g. `useQuery`) is subscribed to the `Operation`, then `reexecuteOperation` will do nothing.\n   *\n   * All operations are put onto a queue and executed after a micro-tick. The queue of operations is\n   * emptied eagerly and synchronously, similar to a trampoline scheduler.\n   */\n  reexecuteOperation(operation: Operation): void;\n\n  /** Subscribe method to add an event listener to debug events.\n   *\n   * @param onEvent - A callback called with new debug events, each time an `Exchange` issues them.\n   * @returns A Wonka {@link Subscription} which is used to optionally terminate the event listener.\n   *\n   * @remarks\n   * This is a method that's only available in development, and allows the `urql-devtools` to receive\n   * to debug events that are issued by exchanges, giving the devtools more information about the flow\n   * and execution of {@link Operation | Operations}.\n   *\n   * @see {@link DebugEventTypes} for a description of all debug events.\n   * @internal\n   */\n  subscribeToDebugTarget?(onEvent: (event: DebugEvent) => void): Subscription;\n\n  /** Creates an `Operation` from a `GraphQLRequest` and optionally, overriding `OperationContext` options.\n   *\n   * @param kind - The {@link OperationType} of GraphQL operation, i.e. `query`, `mutation`, or `subscription`.\n   * @param request - A {@link GraphQLRequest} created prior to calling this method.\n   * @param opts - {@link OperationContext} options that'll override and be merged with options from the {@link ClientOptions}.\n   * @returns An {@link Operation} created from the parameters.\n   *\n   * @remarks\n   * This method is expected to be called with a `kind` set to the `OperationType` of the GraphQL operation.\n   * In development, this is enforced by checking that the GraphQL document's operation matches this `kind`.\n   *\n   * Hint: While bindings will use this method combined with {@link Client.executeRequestOperation}, if\n   * you’re executing operations manually, you can use one of the other convenience methods instead.\n   *\n   * @see {@link Client.executeRequestOperation} for the method used to execute operations.\n   * @see {@link createRequest} which creates a `GraphQLRequest` from a `DocumentNode` and variables.\n   */\n  createRequestOperation<\n    Data = any,\n    Variables extends AnyVariables = AnyVariables,\n  >(\n    kind: OperationType,\n    request: GraphQLRequest<Data, Variables>,\n    opts?: Partial<OperationContext> | undefined\n  ): Operation<Data, Variables>;\n\n  /** Creates a `Source` that executes the `Operation` and issues `OperationResult`s for this `Operation`.\n   *\n   * @param operation - {@link Operation} that will be executed.\n   * @returns A Wonka {@link Source} of {@link OperationResult | OperationResults} for the passed `Operation`.\n   *\n   * @remarks\n   * The {@link Operation} will be dispatched to the pipeline of {@link Exchange | Exchanges} when\n   * subscribing to the returned {@link Source}, which issues {@link OperationResult | OperationResults}\n   * belonging to this `Operation`.\n   *\n   * Internally, {@link OperationResult | OperationResults} are filtered and deliverd to this source by\n   * comparing the {@link Operation.key} on the operation and the {@link OperationResult.operation}.\n   * For mutations, the {@link OperationContext._instance | `OperationContext._instance`} will additionally be compared, since two mutations\n   * with, even given the same variables, will have two distinct results and will be executed separately.\n   *\n   * The {@link Client} dispatches the {@link Operation} when we subscribe to the returned {@link Source}\n   * and will from then on consider the `Operation` as “active” until we unsubscribe. When all consumers unsubscribe\n   * from an `Operation` and it becomes “inactive” a `teardown` signal will be dispatched to the\n   * {@link Exchange | Exchanges}.\n   *\n   * Hint: While bindings will use this method, if you’re executing operations manually, you can use one\n   * of the other convenience methods instead, like {@link Client.executeQuery} et al.\n   */\n  executeRequestOperation<\n    Data = any,\n    Variables extends AnyVariables = AnyVariables,\n  >(\n    operation: Operation<Data, Variables>\n  ): OperationResultSource<OperationResult<Data, Variables>>;\n\n  /** Creates a `Source` that executes the GraphQL query operation created from the passed parameters.\n   *\n   * @param query - a GraphQL document containing the query operation that will be executed.\n   * @param variables - the variables used to execute the operation.\n   * @param opts - {@link OperationContext} options that'll override and be merged with options from the {@link ClientOptions}.\n   * @returns A {@link OperationResultSource} issuing the {@link OperationResult | OperationResults} for the GraphQL operation.\n   *\n   * @remarks\n   * The `Client.query` method is useful to programmatically create and issue a GraphQL query operation.\n   * It automatically calls {@link createRequest}, {@link client.createRequestOperation}, and\n   * {@link client.executeRequestOperation} for you, and is a convenience method.\n   *\n   * Since it returns a {@link OperationResultSource} it may be chained with a `toPromise()` call to only\n   * await a single result in an async function.\n   *\n   * Hint: This is the recommended way to create queries programmatically when not using the bindings,\n   * or when you’re trying to get a single, promisified result.\n   *\n   * @example\n   * ```ts\n   * const getBookQuery = gql`\n   *   query GetBook($id: ID!) {\n   *     book(id: $id) {\n   *       id\n   *       name\n   *       author {\n   *         name\n   *       }\n   *     }\n   *   }\n   * `;\n   *\n   * async function getBook(id) {\n   *   const result = await client.query(getBookQuery, { id }).toPromise();\n   *   if (result.error) {\n   *     throw result.error;\n   *   }\n   *\n   *   return result.data.book;\n   * }\n   * ```\n   */\n  query<Data = any, Variables extends AnyVariables = AnyVariables>(\n    query: DocumentInput<Data, Variables>,\n    variables: Variables,\n    context?: Partial<OperationContext>\n  ): OperationResultSource<OperationResult<Data, Variables>>;\n\n  /** Returns the first synchronous result a `Client` provides for a given operation.\n   *\n   * @param query - a GraphQL document containing the query operation that will be executed.\n   * @param variables - the variables used to execute the operation.\n   * @param opts - {@link OperationContext} options that'll override and be merged with options from the {@link ClientOptions}.\n   * @returns An {@link OperationResult} if one became available synchronously or `null`.\n   *\n   * @remarks\n   * The `Client.readQuery` method returns a result synchronously or defaults to `null`. This is useful\n   * as it limits the result for a query operation to whatever the cache {@link Exchange} of a {@link Client}\n   * had stored and available at that moment.\n   *\n   * In `urql`, it's expected that cache exchanges return their results synchronously. The bindings\n   * and this method exploit this by using synchronous results, like these, to check what data is already\n   * in the cache.\n   *\n   * This method is similar to what all bindings do to synchronously provide the initial state for queries,\n   * regardless of whether effects afterwards that subscribe to the query operation update this state synchronously\n   * or asynchronously.\n   */\n  readQuery<Data = any, Variables extends AnyVariables = AnyVariables>(\n    query: DocumentInput<Data, Variables>,\n    variables: Variables,\n    context?: Partial<OperationContext>\n  ): OperationResult<Data, Variables> | null;\n\n  /** Creates a `Source` that executes the GraphQL query operation for the passed `GraphQLRequest`.\n   *\n   * @param query - a {@link GraphQLRequest}\n   * @param opts - {@link OperationContext} options that'll override and be merged with options from the {@link ClientOptions}.\n   * @returns A {@link PromisifiedSource} issuing the {@link OperationResult | OperationResults} for the GraphQL operation.\n   *\n   * @remarks\n   * The `Client.executeQuery` method is used to programmatically issue a GraphQL query operation.\n   * It automatically calls {@link client.createRequestOperation} and {@link client.executeRequestOperation} for you,\n   * but requires you to create a {@link GraphQLRequest} using {@link createRequest} yourself first.\n   *\n   * @see {@link Client.query} for a method that doesn't require calling {@link createRequest} yourself.\n   */\n  executeQuery<Data = any, Variables extends AnyVariables = AnyVariables>(\n    query: GraphQLRequest<Data, Variables>,\n    opts?: Partial<OperationContext> | undefined\n  ): OperationResultSource<OperationResult<Data, Variables>>;\n\n  /** Creates a `Source` that executes the GraphQL subscription operation created from the passed parameters.\n   *\n   * @param query - a GraphQL document containing the subscription operation that will be executed.\n   * @param variables - the variables used to execute the operation.\n   * @param opts - {@link OperationContext} options that'll override and be merged with options from the {@link ClientOptions}.\n   * @returns A Wonka {@link Source} issuing the {@link OperationResult | OperationResults} for the GraphQL operation.\n   *\n   * @remarks\n   * The `Client.subscription` method is useful to programmatically create and issue a GraphQL subscription operation.\n   * It automatically calls {@link createRequest}, {@link client.createRequestOperation}, and\n   * {@link client.executeRequestOperation} for you, and is a convenience method.\n   *\n   * Hint: This is the recommended way to create subscriptions programmatically when not using the bindings.\n   *\n   * @example\n   * ```ts\n   * import { pipe, subscribe } from 'wonka';\n   *\n   * const getNewsSubscription = gql`\n   *   subscription GetNews {\n   *     breakingNews {\n   *       id\n   *       text\n   *       createdAt\n   *     }\n   *   }\n   * `;\n   *\n   * function subscribeToBreakingNews() {\n   *   const subscription = pipe(\n   *     client.subscription(getNewsSubscription, {}),\n   *     subscribe(result => {\n   *       if (result.data) {\n   *         console.log(result.data.breakingNews.text);\n   *       }\n   *     })\n   *   );\n   *\n   *   return subscription.unsubscribe;\n   * }\n   * ```\n   */\n  subscription<Data = any, Variables extends AnyVariables = AnyVariables>(\n    query: DocumentInput<Data, Variables>,\n    variables: Variables,\n    context?: Partial<OperationContext>\n  ): OperationResultSource<OperationResult<Data, Variables>>;\n\n  /** Creates a `Source` that executes the GraphQL subscription operation for the passed `GraphQLRequest`.\n   *\n   * @param query - a {@link GraphQLRequest}\n   * @param opts - {@link OperationContext} options that'll override and be merged with options from the {@link ClientOptions}.\n   * @returns A {@link PromisifiedSource} issuing the {@link OperationResult | OperationResults} for the GraphQL operation.\n   *\n   * @remarks\n   * The `Client.executeSubscription` method is used to programmatically issue a GraphQL subscription operation.\n   * It automatically calls {@link client.createRequestOperation} and {@link client.executeRequestOperation} for you,\n   * but requires you to create a {@link GraphQLRequest} using {@link createRequest} yourself first.\n   *\n   * @see {@link Client.subscription} for a method that doesn't require calling {@link createRequest} yourself.\n   */\n  executeSubscription<\n    Data = any,\n    Variables extends AnyVariables = AnyVariables,\n  >(\n    query: GraphQLRequest<Data, Variables>,\n    opts?: Partial<OperationContext> | undefined\n  ): OperationResultSource<OperationResult<Data, Variables>>;\n\n  /** Creates a `Source` that executes the GraphQL mutation operation created from the passed parameters.\n   *\n   * @param query - a GraphQL document containing the mutation operation that will be executed.\n   * @param variables - the variables used to execute the operation.\n   * @param opts - {@link OperationContext} options that'll override and be merged with options from the {@link ClientOptions}.\n   * @returns A {@link PromisifiedSource} issuing the {@link OperationResult | OperationResults} for the GraphQL operation.\n   *\n   * @remarks\n   * The `Client.mutation` method is useful to programmatically create and issue a GraphQL mutation operation.\n   * It automatically calls {@link createRequest}, {@link client.createRequestOperation}, and\n   * {@link client.executeRequestOperation} for you, and is a convenience method.\n   *\n   * Since it returns a {@link PromisifiedSource} it may be chained with a `toPromise()` call to only\n   * await a single result in an async function. Since mutations will only typically issue one result,\n   * using this method is recommended.\n   *\n   * Hint: This is the recommended way to create mutations programmatically when not using the bindings,\n   * or when you’re trying to get a single, promisified result.\n   *\n   * @example\n   * ```ts\n   * const createPostMutation = gql`\n   *   mutation CreatePost($text: String!) {\n   *     createPost(text: $text) {\n   *       id\n   *       text\n   *     }\n   *   }\n   * `;\n   *\n   * async function createPost(text) {\n   *   const result = await client.mutation(createPostMutation, {\n   *     text,\n   *   }).toPromise();\n   *   if (result.error) {\n   *     throw result.error;\n   *   }\n   *\n   *   return result.data.createPost;\n   * }\n   * ```\n   */\n  mutation<Data = any, Variables extends AnyVariables = AnyVariables>(\n    query: DocumentInput<Data, Variables>,\n    variables: Variables,\n    context?: Partial<OperationContext>\n  ): OperationResultSource<OperationResult<Data, Variables>>;\n\n  /** Creates a `Source` that executes the GraphQL mutation operation for the passed `GraphQLRequest`.\n   *\n   * @param query - a {@link GraphQLRequest}\n   * @param opts - {@link OperationContext} options that'll override and be merged with options from the {@link ClientOptions}.\n   * @returns A {@link PromisifiedSource} issuing the {@link OperationResult | OperationResults} for the GraphQL operation.\n   *\n   * @remarks\n   * The `Client.executeMutation` method is used to programmatically issue a GraphQL mutation operation.\n   * It automatically calls {@link client.createRequestOperation} and {@link client.executeRequestOperation} for you,\n   * but requires you to create a {@link GraphQLRequest} using {@link createRequest} yourself first.\n   *\n   * @see {@link Client.mutation} for a method that doesn't require calling {@link createRequest} yourself.\n   */\n  executeMutation<Data = any, Variables extends AnyVariables = AnyVariables>(\n    query: GraphQLRequest<Data, Variables>,\n    opts?: Partial<OperationContext> | undefined\n  ): OperationResultSource<OperationResult<Data, Variables>>;\n}\n\nexport const Client: new (opts: ClientOptions) => Client = function Client(\n  this: Client | {},\n  opts: ClientOptions\n) {\n  if (process.env.NODE_ENV !== 'production' && !opts.url) {\n    throw new Error('You are creating an urql-client without a url.');\n  }\n\n  let ids = 0;\n\n  const replays = new Map<number, OperationResult>();\n  const active: Map<number, Source<OperationResult>> = new Map();\n  const dispatched = new Set<number>();\n  const queue: Operation[] = [];\n\n  const baseOpts = {\n    url: opts.url,\n    fetchSubscriptions: opts.fetchSubscriptions,\n    fetchOptions: opts.fetchOptions,\n    fetch: opts.fetch,\n    preferGetMethod: opts.preferGetMethod,\n    requestPolicy: opts.requestPolicy || 'cache-first',\n  };\n\n  // This subject forms the input of operations; executeOperation may be\n  // called to dispatch a new operation on the subject\n  const operations = makeSubject<Operation>();\n\n  function nextOperation(operation: Operation) {\n    if (\n      operation.kind === 'mutation' ||\n      operation.kind === 'teardown' ||\n      !dispatched.has(operation.key)\n    ) {\n      if (operation.kind === 'teardown') {\n        dispatched.delete(operation.key);\n      } else if (operation.kind !== 'mutation') {\n        dispatched.add(operation.key);\n      }\n      operations.next(operation);\n    }\n  }\n\n  // We define a queued dispatcher on the subject, which empties the queue when it's\n  // activated to allow `reexecuteOperation` to be trampoline-scheduled\n  let isOperationBatchActive = false;\n  function dispatchOperation(operation?: Operation | void) {\n    if (operation) nextOperation(operation);\n\n    if (!isOperationBatchActive) {\n      isOperationBatchActive = true;\n      while (isOperationBatchActive && (operation = queue.shift()))\n        nextOperation(operation);\n      isOperationBatchActive = false;\n    }\n  }\n\n  /** Defines how result streams are created */\n  const makeResultSource = (operation: Operation) => {\n    let result$ = pipe(\n      results$,\n      // Filter by matching key (or _instance if it’s set)\n      filter(\n        (res: OperationResult) =>\n          res.operation.kind === operation.kind &&\n          res.operation.key === operation.key &&\n          (!res.operation.context._instance ||\n            res.operation.context._instance === operation.context._instance)\n      ),\n      // End the results stream when an active teardown event is sent\n      takeUntil(\n        pipe(\n          operations.source,\n          filter(op => op.kind === 'teardown' && op.key === operation.key)\n        )\n      )\n    );\n\n    // Mask typename properties if the option for it is turned on\n    if (opts.maskTypename) {\n      result$ = pipe(\n        result$,\n        map(res => ({ ...res, data: maskTypename(res.data, true) }))\n      );\n    }\n\n    if (operation.kind !== 'query') {\n      // Interrupt subscriptions and mutations when they have no more results\n      result$ = pipe(\n        result$,\n        takeWhile(result => !!result.hasNext, true)\n      );\n    } else {\n      result$ = pipe(\n        result$,\n        // Add `stale: true` flag when a new operation is sent for queries\n        switchMap(result => {\n          const value$ = fromValue(result);\n          return result.stale || result.hasNext\n            ? value$\n            : merge([\n                value$,\n                pipe(\n                  operations.source,\n                  filter(op => op.key === operation.key),\n                  take(1),\n                  map(() => {\n                    result.stale = true;\n                    return result;\n                  })\n                ),\n              ]);\n        })\n      );\n    }\n\n    if (operation.kind !== 'mutation') {\n      result$ = pipe(\n        result$,\n        // Store replay result\n        onPush(result => {\n          if (result.stale) {\n            // If the current result has queued up an operation of the same\n            // key, then `stale` refers to it\n            for (const operation of queue) {\n              if (operation.key === result.operation.key) {\n                dispatched.delete(operation.key);\n                break;\n              }\n            }\n          } else if (!result.hasNext) {\n            dispatched.delete(operation.key);\n          }\n          replays.set(operation.key, result);\n        }),\n        // Cleanup active states on end of source\n        onEnd(() => {\n          // Delete the active operation handle\n          dispatched.delete(operation.key);\n          replays.delete(operation.key);\n          active.delete(operation.key);\n          // Interrupt active queue\n          isOperationBatchActive = false;\n          // Delete all queued up operations of the same key on end\n          for (let i = queue.length - 1; i >= 0; i--)\n            if (queue[i].key === operation.key) queue.splice(i, 1);\n          // Dispatch a teardown signal for the stopped operation\n          nextOperation(\n            makeOperation('teardown', operation, operation.context)\n          );\n        })\n      );\n    } else {\n      result$ = pipe(\n        result$,\n        // Send mutation operation on start\n        onStart(() => {\n          nextOperation(operation);\n        })\n      );\n    }\n\n    return share(result$);\n  };\n\n  const instance: Client =\n    this instanceof Client ? this : Object.create(Client.prototype);\n  const client: Client = Object.assign(instance, {\n    suspense: !!opts.suspense,\n    operations$: operations.source,\n\n    reexecuteOperation(operation: Operation) {\n      // Reexecute operation only if any subscribers are still subscribed to the\n      // operation's exchange results\n      if (operation.kind === 'teardown') {\n        dispatchOperation(operation);\n      } else if (operation.kind === 'mutation' || active.has(operation.key)) {\n        let queued = false;\n        for (let i = 0; i < queue.length; i++)\n          queued = queued || queue[i].key === operation.key;\n        if (!queued) dispatched.delete(operation.key);\n        queue.push(operation);\n        Promise.resolve().then(dispatchOperation);\n      }\n    },\n\n    createRequestOperation(kind, request, opts) {\n      if (!opts) opts = {};\n\n      let requestOperationType: string | undefined;\n      if (\n        process.env.NODE_ENV !== 'production' &&\n        kind !== 'teardown' &&\n        (requestOperationType = getOperationType(request.query)) !== kind\n      ) {\n        throw new Error(\n          `Expected operation of type \"${kind}\" but found \"${requestOperationType}\"`\n        );\n      }\n\n      return makeOperation(kind, request, {\n        _instance:\n          kind === 'mutation'\n            ? ((ids = (ids + 1) | 0) as OperationInstance)\n            : undefined,\n        ...baseOpts,\n        ...opts,\n        requestPolicy: opts.requestPolicy || baseOpts.requestPolicy,\n        suspense: opts.suspense || (opts.suspense !== false && client.suspense),\n      });\n    },\n\n    executeRequestOperation(operation) {\n      if (operation.kind === 'mutation') {\n        return withPromise(makeResultSource(operation));\n      }\n\n      return withPromise(\n        lazy<OperationResult>(() => {\n          let source = active.get(operation.key);\n          if (!source) {\n            active.set(operation.key, (source = makeResultSource(operation)));\n          }\n\n          source = pipe(\n            source,\n            onStart(() => {\n              dispatchOperation(operation);\n            })\n          );\n\n          const replay = replays.get(operation.key);\n          if (\n            operation.kind === 'query' &&\n            replay &&\n            (replay.stale || replay.hasNext)\n          ) {\n            return pipe(\n              merge([\n                source,\n                pipe(\n                  fromValue(replay),\n                  filter(replay => replay === replays.get(operation.key))\n                ),\n              ]),\n              switchMap(fromValue)\n            );\n          } else {\n            return source;\n          }\n        })\n      );\n    },\n\n    executeQuery(query, opts) {\n      const operation = client.createRequestOperation('query', query, opts);\n      return client.executeRequestOperation(operation);\n    },\n\n    executeSubscription(query, opts) {\n      const operation = client.createRequestOperation(\n        'subscription',\n        query,\n        opts\n      );\n      return client.executeRequestOperation(operation);\n    },\n\n    executeMutation(query, opts) {\n      const operation = client.createRequestOperation('mutation', query, opts);\n      return client.executeRequestOperation(operation);\n    },\n\n    readQuery(query, variables, context) {\n      let result: OperationResult | null = null;\n\n      pipe(\n        client.query(query, variables, context),\n        subscribe(res => {\n          result = res;\n        })\n      ).unsubscribe();\n\n      return result;\n    },\n\n    query(query, variables, context) {\n      return client.executeQuery(createRequest(query, variables), context);\n    },\n\n    subscription(query, variables, context) {\n      return client.executeSubscription(\n        createRequest(query, variables),\n        context\n      );\n    },\n\n    mutation(query, variables, context) {\n      return client.executeMutation(createRequest(query, variables), context);\n    },\n  } as Client);\n\n  let dispatchDebug: ExchangeInput['dispatchDebug'] = noop;\n  if (process.env.NODE_ENV !== 'production') {\n    const { next, source } = makeSubject<DebugEvent>();\n    client.subscribeToDebugTarget = (onEvent: (e: DebugEvent) => void) =>\n      pipe(source, subscribe(onEvent));\n    dispatchDebug = next as ExchangeInput['dispatchDebug'];\n  }\n\n  // All exchange are composed into a single one and are called using the constructed client\n  // and the fallback exchange stream\n  const composedExchange = composeExchanges(opts.exchanges);\n\n  // All exchanges receive inputs using which they can forward operations to the next exchange\n  // and receive a stream of results in return, access the client, or dispatch debugging events\n  // All operations then run through the Exchange IOs in a pipeline-like fashion\n  const results$ = share(\n    composedExchange({\n      client,\n      dispatchDebug,\n      forward: fallbackExchange({ dispatchDebug }),\n    })(operations.source)\n  );\n\n  // Prevent the `results$` exchange pipeline from being closed by active\n  // cancellations cascading up from components\n  pipe(results$, publish);\n\n  return client;\n} as any;\n\n/** Accepts `ClientOptions` and creates a `Client`.\n * @param opts - A {@link ClientOptions} objects with options for the `Client`.\n * @returns A {@link Client} instantiated with `opts`.\n */\nexport const createClient = Client as any as (opts: ClientOptions) => Client;\n"],"names":["collectTypes","obj","types","Array","isArray","item","key","add","collectTypenames","response","Set","formatNode","node","definitions","definition","newDefinition","push","directives","length","_directives","directive","name","value","slice","selections","hasTypename","kind","Kind","OPERATION_DEFINITION","selectionSet","selection","FIELD","alias","newSelection","NAME","_generated","formattedDocs","Map","formatDocument","query","keyDocument","result","get","__key","set","Object","defineProperty","enumerable","maskTypename","data","isRoot","map","d","acc","__typename","withPromise","_source$","source$","sink","toPromise","take","filter","stale","hasNext","then","onResolve","onReject","subscribe","onResult","makeOperation","request","context","addMetadata","operation","meta","noop","gql","parts","fragmentNames","source","body","i","arguments","unshift","document","FRAGMENT_DEFINITION","stringifyDocument","has","process","env","NODE_ENV","console","warn","DOCUMENT","shouldSkip","mapTypeNames","formattedOperation","cacheExchange","forward","client","dispatchDebug","resultCache","operationCache","isOperationCached","requestPolicy","ops$","cachedOps$","cachedResult","type","message","undefined","makeResult","cacheOutcome","reexecuteOperation","op","forwardedOps$","tap","typenames","additionalTypenames","concat","pendingOperations","typeName","operations","values","clear","delete","merge","serializeResult","includeExtensions","serialized","JSON","stringify","extensions","error","graphQLErrors","path","networkError","deserializeResult","parse","CombinedError","Error","revalidated","ssrExchange","params","staleWhileRevalidate","invalidateQueue","invalidate","Promise","resolve","shift","ssr","isClient","suspense","restoreData","restore","extractData","initialState","subscriptionExchange","forwardSubscription","enableAllOperations","isSubscriptionOperation","createSubscriptionSource","observableish","makeFetchBody","make","observer","isComplete","sub","nextResult","next","mergeResultPatch","errors","makeErrorResult","complete","unsubscribe","isSubscriptionOperationFn","subscriptionResults$","mergeMap","teardown$","takeUntil","forward$","debugExchange","log","dedupExchange","fetchExchange","fetchResults$","url","makeFetchURL","fetchOptions","makeFetchOptions","makeFetchSource","onPush","fetchSubscriptions","composeExchanges","exchanges","reduceRight","exchange","forwarded","operations$","share","event","timestamp","Date","now","mapExchange","onOperation","onError","newResult","fromPromise","fromValue","newOperation","fallbackExchange","_x","Client","opts","ids","replays","active","dispatched","queue","baseOpts","fetch","preferGetMethod","makeSubject","nextOperation","isOperationBatchActive","dispatchOperation","makeResultSource","result$","res","_instance","results$","takeWhile","switchMap","value$","onEnd","splice","onStart","instance","create","prototype","assign","queued","createRequestOperation","requestOperationType","getOperationType","executeRequestOperation","lazy","replay","executeQuery","executeSubscription","executeMutation","readQuery","variables","createRequest","subscription","mutation","subscribeToDebugTarget","onEvent","composedExchange","publish","createClient"],"mappings":"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"}